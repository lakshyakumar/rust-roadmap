1. Barebones HTTP Server: Implement a tiny async web server with tokio. Handle GET/POST routes manually.
2. Router Layer: Add routing logic (pattern matching paths, e.g. /users/:id).
3. Request Throttling: Implement per-IP rate limiting (token bucket / leaky bucket).
4. Middleware System: Design a pluggable middleware trait (logging, auth, throttling).
5. Connection Pool: Build a simple database connection pool with Arc<Mutex<Vec<Conn>>>.
6. Caching Layer: Add an in-memory cache with HashMap + LRU eviction.
7. Persistent Store: Swap the cache backend for sled (embedded DB). Compare performance.
8. Authentication Service: Implement JWT-based auth middleware.
9. Session Management: Add session store with Redis. Handle expiry & concurrent access.
10. Configurable Web Server: Read config from env + toml. Allow toggling features.
11. Graceful Shutdown: Add signal handling. Ensure in-flight requests finish.
12. Metrics Layer: Expose /metrics in Prometheus format (req/sec, latency).
13. Task Scheduling: Implement a lightweight cron scheduler (async tasks at intervals).
14. Worker Pool: Create a pool of async workers handling jobs from a channel.
15. Pub/Sub System: Build a message broker with channels (fanout to multiple subscribers).
16. Sharded Cache: Partition your cache across multiple worker tasks (consistent hashing).
17. Reverse Proxy: Implement a proxy that forwards requests to multiple backend servers.
18. Load Balancer: Add round-robin / least-connections balancing for backends.
19. Circuit Breaker: Implement failure detection → stop calling a broken backend temporarily.
20. Distributed Logging: Collect logs from multiple services and aggregate them centrally.
21. Event Sourcing: Store all requests/events in append-only log. Rebuild state from log.
22. CQRS Pattern: Split reads/writes: one service handles commands, another queries.
23. API Gateway: Design a gateway that authenticates, throttles, and routes to microservices.
24. Microservice Split: Split your monolith into 2 services (e.g., User + Orders). Use async HTTP/RPC between them.
25. Distributed Locking: Implement a lock service backed by Redis/etcd to coordinate workers.
26. Task Queue: Build a job queue with retries, dead-letter queue, visibility timeouts.
27. Streaming Service: Stream data chunks over WebSockets. Handle backpressure.
28. Horizontal Scaling: Simulate multiple servers behind a load balancer. Share state via Redis.
29. Chaos Testing: Introduce random failures, latency, crashes. Make your system resilient.
30. Capstone: Scalable Web Platform → Combine everything: API Gateway → Auth → Cache → Database → Worker Pool → Metrics → Logging → Configurable scaling. Deploy multiple instances (simulate with Docker or k8s).
